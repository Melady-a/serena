<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="style.css" type="text/css" />
<title>Untitled Document</title>

<style type="text/css">
<!--
.style4 {color:#663333}
.style5 {
	font-family: "Bookman Old Style";
	font-weight: bold;
	color:#000099
}
.style6 {font-size: 12px}
.style7 {font-family: "Bookman Old Style"; font-weight: bold; color: #999900; font-size: 12px; }
.style8 {font-family: "Bookman Old Style"; font-weight: bold; color: #66FFFF; font-size: 14px; }
-->
</style>
</head>

<body>
<img src="img/php.jpg" width="100%" height="150" />
<table width="240" height="232" border="1" bordercolor="#CC6699" class="menu" >
  <tr>
    <td width="228" class="mtd"><a href="index.php"  class="a style4"  style="text-decoration:none">История PHP </a></td>
  </tr>
  <tr>
   <td class="mtd"><a href="bases.php"  class="a style4"  style="text-decoration:none">Основы PHP </a></td> 
  </tr>
  <tr>
  <td class="mtd"><a href="operators.php"  class="a style4"  style="text-decoration:none">Операторы языка PHP</a></td>
     
  </tr>
  <tr>
  <td height="24" class="mtd"><a href="string.php"  class="a style4"  style="text-decoration:none">Строковые функции PHP</a></td>
   
  </tr>
  <tr>
    <td class="mtd"><a href="array.php" class="a style4"  style="text-decoration:none">Массивы </a></td>
  </tr>
  <tr>
    <td class="mtd"><a href="function.php" class="a style4"  style="text-decoration:none"> Функции  </a></td>
  </tr>
  <tr>
    <td height="41" class="mtd"><a href="expression.php"  class="a style4"  style="text-decoration:none" >Регулярные выражения  </a></td>
  </tr>
    <tr>
    <td height="37" class="mtd"><a href="file.php"  class="a style4"  style="text-decoration:none" >Работа с файлами  </a></td>
  </tr>
</table>
<table width="268" border="0" bordercolor="#CC6699"  style="position:fixed; width: 241px; left: 14px; top: 476px; height: 244px;" >
  <tr>
    <td width="260" height="25" class="mtd"><a href="phpsql.php#sqlphp"  class="style7"  style="text-decoration:none">Что такое MySQL. Взаимодействие с PHP</a></td>
  </tr>
  <tr>
    <td height="25" class="mtd"><a href="phpsql.php#relation"  class="style7"  style="text-decoration:none">Реляционные базы данных</a></td>
  </tr>
  <tr>
    <td height="25" class="mtd"><a href="phpsql.php#index"  class="style7"  style="text-decoration:none">Индексы</a></td>
  </tr>
  <tr>
    <td height="25" class="mtd"><a href="phpsql.php#key"  class="style7"  style="text-decoration:none">Первичные ключи</a></td>
  </tr>
    <tr>
    <td height="30" class="mtd"><a href="phpsql.php#keyset"  class="style7"  style="text-decoration:none">Способы задания первичного ключа</a></td>
  </tr>
    <tr>
    <td height="25" class="mtd"><a href="phpsql.php#db"  class="style7"  style="text-decoration:none">Нормализация базы данных</a></td>
  </tr>
    <tr>
    <td height="25" class="mtd"><a href="phpsql.php#server"  class="style7"  style="text-decoration:none">Работа с сервером MySQL</a></td>
  </tr>
    <tr>
    <td height="25" class="mtd"><a href="phpsql.php#sql"  class="style7"  style="text-decoration:none">Язык SQL</a></td>
  </tr> 
 
</table>

<div class="pclass" style="position:absolute; left: 260px; top: 170px; width: 686px; height: 302px;">
  <h4 align="center" class="style4"> PHP и MySQL. Совместная работа</h4>
  <a name=#sqlphp>
  <p>&nbsp;</p>
  <h4 class="style5">Что такое MySQL. Взаимодействие с PHP</h4>
  <p>Итак, для начала ответим на вопрос: что такое MySQL?</p>
  <p><strong>MySQL</strong> – это одна из самых популярных и самых   распространенных СУБД (система управления базами данных) в интернете. Она не   предназначена для работы с большими объемами информации, но ее применение   идеально для интернет сайтов, как небольших, так и достаточно крупных.</p>
  <p><strong>MySQL</strong> отличатся хорошей скоростью работы, надежностью,   гибкостью. Работа с ней, как правило, не вызывает больших трудностей. Поддержка   сервера MySQL автоматически включается в поставку PHP.</p>
  <p>Немаловажным фактором является ее бесплатность. MySQL   распространяется на условиях общей лицензии GNU (GPL, GNU Public License).</p>
  <p>Ранее для долговременного хранения информации мы работали с   файлами: помещали в них некоторое количество строчек, а затем извлекали их для   последующей работы. Задача длительного хранения информации очень часто   встречается в программировании Web-приложений: подсчёт посетителей в счётчике,   хранение сообщений в форуме, удалённое управление содержанием информации на   сайте и т.д.</p>
  <p>Между тем, профессиональные приёмы работы с файлами очень   трудоёмки: необходимо заботится о помещении в них информации, о её сортировке,   извлечении, при этом не нужно забывать, что все эти действия будут происходить   на сервере хост-провайдера, где с очень большой вероятностью стоит один из   вариантов Unix - следовательно, нужно так же заботится о правах доступа к файлам   и их размещении. При этом объём кода значительно возрастает, и совершить ошибку   в программе очень просто.</p>
  <p>Все эти проблемы решает использование базы данных. Базы данных   сами заботятся о безопасности информации и её сортировке и позволяют извлекать и   размещать информацию при помощи одной строчки. Код с использованием базы данных   получается более компактным, и отлаживать его гораздо легче. Кроме того, не   нужно забывать и о скорости - выборка информации из базы данных происходит   значительно быстрее, чем из файлов.</p>
  <p><strong><em>Примечание</em></strong></p>
  <p>Приложение на РНР, использующее для хранения информации базу   данных (в частности MySql) всегда работает быстрее приложения, построенного на   файлах. Дело в том, что базы данных написаны на языке C++, и написать на PHP   программу, которая работала бы с жёстким диском эффективнее базы данных - задача   неразрешимая по определению, поскольку программы на PHP в принципе работают   медленнее, чем программы на C++, так как РНР - интерпретатор, а С++ -   компилятор.</p>
  <p>Таким образом, основное достоинство базы данных заключается в том,   что она берёт на себя всю работу с жёстким диском и делает это очень эффективно.</p>
  <a name=#relation>
  <h4 class="style5">Реляционные базы данных</h4>
 <br>
  <p>Задача длительного хранения и обработки информации появилась   практически сразу с появлением первых компьютеров. Для решения этой задачи в   конце 60-х годов были разработаны специализированные программы, получившие   название <strong>систем управления базами данных</strong> (СУБД). СУБД проделали   длительный путь эволюции от системы управления файлами, через иерархические и   сетевые базы данных. В конце 80-х годов доминирующей стала <strong>система управления   реляционными базами данных</strong> (СУРБД). С этого времени такие СУБД стали   стандартом де-факто, и для того, чтобы унифицировать работу с ними, был   разработан <strong>структурированный язык запросов</strong> (SQL), который представляет   собой язык управления именно реляционными базами данных.</p>
  <p><strong><em>Замечание</em></strong></p>
  <p>Взаимодействие с базой данных происходит при помощи Системы   Управления Базой Данных (СУБД), которая расшифровывает запросы и производит   операции с информацией в базе данных. Поэтому более правильно было бы говорить о   запросе к СУБД и о взаимодействии с СУБД из Web-приложения. Но так как это   несколько усложняет восприятие, далее везде мы будем говорить &quot;база данных&quot;,   подразумевая при этом СУБД.</p>
  <p>Существуют следующие разновидности баз данных:</p>
  <ul>
    <li>иерархические; </li>
    <li>реляционные; </li>
    <li>объектно-ориентированные; </li>
    <li>гибридные. </li>
  </ul>
  <p><strong>Иерархическая</strong> база данных основана на древовидной структуре   хранения информации. В этом смысле иерархические базы данных очень напоминают   файловую систему компьютера.</p>
  <p>В <strong>реляционных</strong> базах данных данные собраны в таблицы,   которые в свою очередь состоят из столбцов и строк, на пересечении которых   расположены ячейки. Запросы к таким базам данных возвращает таблицу, которая   повторно может участвовать в следующем запросе. Данные в одних таблицах, как   правило, связаны с данными других таблиц, откуда и произошло название   &quot;реляционные&quot;.</p>
  <p>В <strong>объектно-ориентированных</strong> базах данных данные хранятся в   виде объектов. С объектно-ориентированными базами данных удобно работать,   применяя объектно-ориентированное программирование. Однако, на сегодняшний день   такие базы дан-ных еще не достигли популярности реляционных, поскольку пока   значительно уступают им в производительности.</p>
  <p><strong>Гибридные</strong> СУБД совмещают в себе возможности реляционных и   объектно-ориентированных баз данных.</p>
  <p>В Web-приложениях, как правило, используются реляционные базы   данных. Мы будем рассматривать пример базы данных, на которой основано   большинство форумов, в том числе и тот, который мы далее будем разрабатывать. В   этой базе хранится информация об авторах форума (authors), о названиях форумов   (forums), о темах форума (themes) и, собственно, сами сообщения (posts). Таким   образом, наша база данных будет включать следующие таблицы:</p>
  <p><strong>Таблица 1</strong> Таблицы базы данных Forum.</p>
  <table cellspacing="1" width="30%" border="1">
    <tbody>
      <tr>
        <td valign="top"><p align="center">authors</p></td>
      </tr>
      <tr>
        <td valign="top"><p align="center">forums</p></td>
      </tr>
      <tr>
        <td valign="top"><p align="center">posts</p></td>
      </tr>
      <tr>
        <td valign="top"><p align="center">themes</p></td>
      </tr>
    </tbody>
  </table>
  <p>Модель реляционной базы данных представляет данные в виде таблиц,   разбитых на строки и столбцы, на пересечении которых находятся данные. Пример   такой таблицы показан в Табл.2:</p>
  <p><strong>Таблица 2</strong> Структура реляционной базы данных.</p>
  <table cellspacing="1" width="80%" border="1">
    <tbody>
      <tr>
        <td valign="top" width="11%"> </td>
        <td valign="top" width="14%"><p><strong>ряд</strong></p></td>
        <td valign="top" width="13%"> </td>
        <td valign="top" width="62%"> </td>
      </tr>
      <tr>
        <td valign="top" width="11%"><p><strong>строка</strong></p></td>
        <td valign="top" width="14%"><p><strong>id_forum</strong></p></td>
        <td valign="top" width="13%"><p><strong>name</strong></p></td>
        <td valign="top" width="62%"><p><strong>Description</strong></p></td>
      </tr>
      <tr>
        <td valign="top" width="11%"> </td>
        <td valign="top" width="14%"><p align="justify">1</p></td>
        <td valign="top" width="13%"><p align="justify">дизайн</p></td>
        <td valign="top" width="62%"><p align="justify">Обсуждаются вопросы дизайна</p></td>
      </tr>
      <tr>
        <td valign="top" width="11%"> </td>
        <td valign="top" width="14%"><p align="justify">2</p></td>
        <td valign="top" width="13%"><p align="justify">MySQL</p></td>
        <td valign="top" width="62%"><p align="justify">Обсуждаются вопросы, связанные с MySQL</p></td>
      </tr>
      <tr>
        <td valign="top" width="11%"> </td>
        <td valign="top" width="14%"><p align="justify">3</p></td>
        <td valign="top" width="13%"><p align="justify">PHP</p></td>
        <td valign="top" width="62%"><p align="justify">Обсуждаются вопросы, связанные с PHP</p></td>
      </tr>
      <tr>
        <td valign="top" width="11%"> </td>
        <td valign="top" width="14%"><p align="justify">4</p></td>
        <td valign="top" width="13%"><p align="justify">разное</p></td>
        <td valign="top" width="62%"><p align="justify">Другие вопросы</p></td>
      </tr>
    </tbody>
  </table>
  <p>В табл.2 приведён пример таблицы forums базы данных большого   форума, в котором имеется несколько разделов, посвящённых различным этапам   построения Web-приложения. Каждая строка этой таблицы представляет собой один   раздел форума. Четыре строки таблицы представляют собой весь форум.</p>
  <p>Каждый столбец таблицы forums представляет один элемент данных для   каждого из форумов. Столбец id_forum содержит уникальный идентификатор форума,   столбец name содержит название форума и столбец description содержит краткое   описание проблемы, обсуждаемой на форуме.</p>
  <p>Кратко особенности реляционной базы данных можно описать следующим   образом:</p>
  <ul>
    <li>Данные хранятся в таблицах, состоящих из столбцов и строк; </li>
    <li>На пересечении каждого столбца и строчки стоит в точности одно значение; </li>
    <li>У каждого столбца есть своё имя, которое служит его названием, и все   значения в одном столбце имеют один тип. Например, в столбце id_forum все   значения имеют целочисленный тип, а в строке name - текстовый; </li>
    <li>Столбцы располагаются в определённом порядке, который определяется при   создании таблицы, в отличие от строк, которые располагаются в произвольном   порядке. В таблице может не быть не одной строчки, но обязательно должен быть   хотя бы один столбец; </li>
  </ul>
  <p>Запросы к базе данных возвращают результат в виде таблиц, которые   тоже могут выступать как объект запросов.</p>
  <a name=#index>
     <h4 class="style5">Индексы</h4>
 <br>
 <p><strong><em>Определение</em></strong></p>
 <p>Индекс - это отсортированный список значений полей,   предназначенный для ускорения поиска в базе данных.</p>
 <p>Интересны, как правило, не сами индексы, а уникальные индексы.</p>
 <p>Уникальный индекс представляет собой список значений, в котором</p>
 <p> каждое значение уникально. К примеру, в таблице базы данных,</p>
 <p> содержащей   паспортные данные уникальный индекс можно создать </p>
 <p>для поля &quot;номер паспорта&quot;,   поскольку каждый такой номер является</p>
 <p> единственным в своём роде. А вот дата   рождения уже не уникальна,</p>
 <p> поэтому индекс по полю &quot;Дата рождения&quot; не может быть   уникальным. </p>
 <p>Возвращаясь к нашей базе данных Forum, нужно заметить, что дата   </p>
 <p>добавления сообщения в форум также не является уникальной, так</p>
 <p> как несколько   участников форума могут добавить свои сообщения одновременно.</p>
 <a name=#key>
 <h4 class="style5">Первичные ключи</h4>
 <br>
 <p><strong>Первичный ключ</strong> (primary key) представляет собой один из   примеров </p>
 <p>уникальных индексов и применяется для уникальной идентификации</p>
 <p> записей   таблицы. Никакие из двух записей таблицы не могут иметь </p>
 <p>одинаковых значений   первичного ключа. Первичный ключ обычно </p>
 <p>сокращенно обозначают как PK (primary   key).</p>
 <p>Как мы уже говорили, в реляционных базах данных практически </p>
 <p>всегда   разные таблицы логически связаны друг с другом. </p>
 <p>Первичные ключи как раз   используются для однозначной организации такой связи.</p>
 <a name=#keyset>
 <h4 class="style5">Способы задания первичного ключа</h4>
 <p>По способу задания первичных ключей различают <strong>логические</strong></p>
 <p> (естественные) ключи и <strong>суррогатные</strong> (искусственные).</p>
 <p>Для логического задания первичного ключа нужно выбрать в базе</p>
 <p> данных то, что естественным образом определяет запись. Примером </p>
 <p>такого ключа   является номер паспорта в базе данных о паспортных </p>
 <p>данных жителей.</p>
 <p>Если подходящих примеров для естественного задания первичного</p>
 <p> ключа не находится, пользуются суррогатным ключом. Суррогатный </p>
 <p>ключ представляет   собой до-полнительное поле в базе данных,</p>
 <p> предназначенное для обеспечения   записей первичным ключом. </p>
 <p><strong><em>Совет:</em></strong></p>
 <p>Даже если в базе данных содержится естественный первичный ключ,</p>
 <p> лучше использовать суррогатные ключи, поскольку их применение </p>
 <p>позволяет   абстрагировать первичный ключ от реальных данных. </p>
 <p>В этом случае облегчается   работа с таблицами, поскольку суррогатные</p>
 <p> ключи не связаны ни с какими   фактическими данными этой таблицы.</p>
 <p>Первичному ключу можно присвоить атрибут auto_increment,</p>
 <p> позволяющий автоматически генерировать уникальный ключ, </p>
 <p>если его тип является   целочисленным. При вставке записи в</p>
 <p> базу данных значение ключа выставляется   равным нулю, MySQL</p>
 <p> автоматически вычисляет максимальный номер первичного ключа,</p>
 <p> увеличивает его на единицу и присваивает это значение первичному ключу новой   записи.</p>
 <p class="pclass">&nbsp;</p>
 <a name=#db>
 <h4 class="style5">Нормализация базы данных</h4>
 
   <p><strong><em>Определение:</em></strong></p>
   <p><em>Схемой базы данных называется структура связей между полями и   таблицами.</em></p>
   <p><strong><em>Определение:</em></strong></p>
   <p><em>Нормализацией схемы базы данных называется процедура,</em></p>
   <p><em> производимая над базой данных с целью удаления в ней избыточности.</em></p>
   <p>Нормализация несет с собой немало преимуществ. Очевидно,</p>
   <p> что в   нормализованной базе данных уменьшается вероятность </p>
   <p>возникновения ошибок, она   занимает меньше места на жестком диске и т.д.</p>
   <p>Для того, чтобы лучше уяснить приведенное определение</p>
   <p> нормализации, рассмотрим следующий пример. Ниже </p>
   <p>показана таблица, в которой   указаны фамилии сотрудников и их профессии:</p>
   <p><strong>Таблица 3.</strong> Пример избыточности в таблицах базы данных</p>
   <table cellspacing="1" cellpadding="7" width="80%" border="1">
     <tbody>
       <tr>
         <td valign="top" width="64%"><p><strong>Профессия</strong></p></td>
         <td valign="top" width="36%"><p><strong>Сотрудник</strong></p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">&quot;Инженер&quot;</p></td>
         <td valign="top" width="36%"><p align="justify">Гусев И.К.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">&quot;Инженер&quot;</p></td>
         <td valign="top" width="36%"><p align="justify">Иванов П.В.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">&quot;Рабочий&quot;</p></td>
         <td valign="top" width="36%"><p align="justify">Иванов К.Л.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">&quot;Рабочий&quot;</p></td>
         <td valign="top" width="36%"><p align="justify">Дружков П.К.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">&quot;Рабочий&quot;</p></td>
         <td valign="top" width="36%"><p align="justify">Фомичев В.М.</p></td>
       </tr>
     </tbody>
   </table>
   <p>Эта таблица избыточна - для каждого из сотрудников повторяются   </p>
   <p>одинаковые названия профессий. Т.е. схема такой базы данных</p>
   <p> не нормализована.   Для небольшой базы данных это не критично, </p>
   <p>но в больших по объёму базах данных   это скажется на размере</p>
   <p> базы и, в конечном счёте, на скорости доступа. Для   нормализации </p>
   <p>необходимо разбить эту таблицу на две - для профессий (см. табл. 4)</p>
   <p> и для фамилий сотрудников (см. табл. 5).</p>
   <p><strong>Таблица 4.</strong> Таблица профессий</p>
   <table cellspacing="1" cellpadding="7" width="80%" border="1">
     <tbody>
       <tr>
         <td valign="top" width="65%"><p align="justify"><strong>Профессия</strong></p></td>
         <td valign="top" width="35%"><p align="justify"><strong>Первичный ключ</strong></p></td>
       </tr>
       <tr>
         <td valign="top" width="65%"><p align="justify">&quot;Инженер&quot;</p></td>
         <td valign="top" width="35%"><p align="justify">1</p></td>
       </tr>
       <tr>
         <td valign="top" width="65%"><p align="justify">&quot;Рабочий&quot;</p></td>
         <td valign="top" width="35%"><p align="justify">2</p></td>
       </tr>
     </tbody>
   </table>
   <p><strong>Таблица 5.</strong> Таблица сотрудников</p>
   <table cellspacing="1" cellpadding="7" width="80%" border="1">
     <tbody>
       <tr>
         <td valign="top" width="64%"><p><strong>Профессия (внешний ключ)</strong></p></td>
         <td valign="top" width="36%"><p><strong>Сотрудник</strong></p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">1</p></td>
         <td valign="top" width="36%"><p align="justify">Гусев И.К.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">1</p></td>
         <td valign="top" width="36%"><p align="justify">Иванов П.В.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">2</p></td>
         <td valign="top" width="36%"><p align="justify">Иванов К.Л.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">2</p></td>
         <td valign="top" width="36%"><p align="justify">Дружков П.К.</p></td>
       </tr>
       <tr>
         <td valign="top" width="64%"><p align="justify">2</p></td>
         <td valign="top" width="36%"><p align="justify">Фомичев В.М.</p></td>
       </tr>
     </tbody>
   </table>
   <p>Теперь каждый тип профессии обозначен уникальным числом, и</p>
   <p> строка   в базе данных присутствует только в единственном экземпляре: </p>
   <p>в таблице   профессий. Размер поля &quot;профессия&quot; уменьшился, так как</p>
   <p> строка занимает больше   памяти, чем число.</p>
   <p><strong><em>Замечание</em></strong></p>
   <p><em>В теории баз данных говорится о том, что схема базы данных   </em></p>
   <p><em>должна быть полностью нормализована. При работе с полностью</em></p>
   <p><em> нормализованными   базами данных необходимо применять весьма</em></p>
   <p><em> сложные SQL-запросы, что приводит к   обратному эффекту - </em></p>
   <p><em>замедлению работы базы данных. Поэтому иногда для упрощения</em></p>
   <p><em> запросов даже прибегают к обратной процедуре - денормализации.</em></p>
   <a name=#server>
   <h4 class="style5">Работа с сервером MySQL</h4>
   
     <p>В этом разделе мы поговорим о том, как работать с клиентской   программой mysql, </p>
     <p>с помощью которой можно подсоединяться к MySQL-серверу,   выполнять</p>
     <p> SQL-запросы и просматривать результаты этих запросов. </p>
     <p>Текст этого   раздела рассчитан на то, что на вашем компьютере</p>
     <p> уже установлена утилита mysql и   существует связь с сервером MySQL.</p>
     <p>При подключении к серверу MySQL с помощью программы mysql </p>
     <p>нужно   ввести имя пользователя, и, как правило, пароль.</p>
     <p> Если сервер и клиент находятся   на разных машинах,</p>
     <p> необходимо также указать имя хоста, на котором запущен сервер   MySQL:</p>
     <blockquote>
       <pre>  shell&gt; mysql -h host -u user -p  </pre>
     </blockquote>
     <p>После этого на экране появится запрос Enter password:,</p>
     <p> и вам нужно   будет ввести свой пароль. Если соединение прошло нормально,</p>
     <p> то на экране   появляется следующая информация и метка командной строки mysql&gt;:</p>
     <blockquote>
       <pre>  Welcome to the MySQL monitor. Commands end with ; or \g.   
 Your MySQL connection id is 459 to server version:    
 Type 'help' for help.    mysql&gt;  </pre>
     </blockquote>
     <p>Появление метки mysql&gt; означает, что программа mysql готова к   работе.</p>
     <p>Отсоединиться от сервера можно в любой момент, набрав команду   QUIT:</p>
     <blockquote>
       <pre>  mysql&gt; QUIT    Bye  </pre>
     </blockquote>
     <p>Кроме этого, разорвать соединение с сервером можно также,   одновременно нажав клавиши +.</p>
     <p><strong><em>Замечание</em></strong></p>
     <p><em>Как правило, на только, что установленном MySQL на локальной   машине</em></p>
     <p><em> доступ осуществляется без ввода пароля и хоста, вводом команды mysql в   командной строке.</em></p>
     <p>После того, как вы подсоединитесь к серверу, для того, чтобы   освоиться</p>
     <p> с синтаксисом команд, можно выполнить несколько простых запросов.   </p>
     <p>Поскольку пока еще никакой базы данных не выбрано, приводимые ниже </p>
     <p>запросы носят   общий характер.</p>
     <p>Ниже приведена простая команда, запрашивающая у сервера информацию   об </p>
     <p>его версии и текущей дате:</p>
     <blockquote>
       <pre>  mysql&gt; SELECT VERSION(), CURRENT_DATE;  </pre>
     </blockquote>
     <p>Ответом MySQL на этот запрос будет следующая таблица:</p>
     <blockquote>
       <pre>  +--------------+--------------------+  
  | version() | current_date |  
  +--------------+--------------------+    
	1 row in set (0.02 sec)  </pre>
     </blockquote>
     <p>На примере выполнения этого запроса можно увидеть следующие   основные</p>
     <p> особенности работы с MySQL:</p>
     <ul>
       <li>Команда, посылаемая серверу, обычно состоит из SQL-выражения,</li>
       <li> за которым   следует точка с запятой. Из этого правила есть несколько </li>
       <li>исключений, когда после   команды точка с запятой не ставится, </li>
       <li>к примеру, уже упомянутая команда QUIT; </li>
       <li>MySQL выводит результаты запроса в виде таблицы; </li>
       <li>После вывода таблицы с результатами запроса, mysql сообщает</li>
       <li> количество   возвращаемых строк и время выполнения запроса.</li>
       <li> Это удобно, поскольку позволяет   оценить как производительность </li>
       <li>сервера, так и эффективность выполняемого   запроса; </li>
       <li>После вывода результатов запроса и времени его выполнения, mysql</li>
       <li> выводит   новую строку mysql&gt;, что означает готовность к выполнению новых команд. </li>
     </ul>
     <p>Заметим, что команды MySQL не чувствительны к регистру, поэтому   </p>
     <p>приведенные ниже запросы абсолютно идентичны:</p>
     <blockquote>
       <pre>  mysql&gt; select version(), current_date;  
  mysql&gt; SELECT VERSION(), CURRENT_DATE;    
mysql&gt; Select Version(), Сurrent_DATE;  </pre>
     </blockquote>
     <p>MySQL позволяет на одной строчке разместить несколько </p>
     <p>команд, но   каждая из них должна заканчиваться точкой с запятой. К примеру:</p>
     <blockquote>
       <pre>  mysql&gt; SELECT VERSION(); SELECT NOW();  </pre>
     </blockquote>
     <p>На такой запрос мы получим следующий результат:</p>
     <blockquote>
       <pre>  +---------------+   
 |  version() |  
  +---------------+    
| 4.0.13-nt |    
+---------------+   
 1 row in set (0.00 sec)  
  +----------------------------------+   
 | NOW()                        |    
+----------------------------------+   
 | 2004-01-25 16:57:00 |    
+----------------------------------+   
 1 row in set (0.03 sec)  </pre>
     </blockquote>
     <p>Однако помещать все команды на одной строке совершенно   необязательно:</p>
     <blockquote>
       <pre>  mysql&gt; SELECT USER(),        -&gt; CURRENT_DATE;  </pre>
     </blockquote>
     <p>И вот результат:</p>
     <blockquote>
       <pre>  +----------------------------+---------------------+  
  | user()                    | current_date |   
 +----------------------------+---------------------+   
 | ODBC@localhost | 2004-01-25   |    
+----------------------------+---------------------+   
  1 row in set (0.00 sec)  </pre>
     </blockquote>
     <p>Заметьте, что после того, как мы перешли на новую строку, метка   командной</p>
     <p> строки изменилась с mysql&gt; на -&gt;.</p>
     <p> Таким образом mysql   показывает, что завершенного запроса не получено </p>
     <p>и она ожидает конца запроса.   Эта метка весьма полезна, так как позволяет</p>
     <p> избежать некоторых ошибок. К   примеру, если вы забудете поставить точку</p>
     <p> с запятой в конце запроса, mysql   сообщит вам об этом, выведя метку -&gt;:</p>
     <blockquote>
       <pre>  mysql&gt; select user()        -&gt;   </pre>
     </blockquote>
     <p>В завершение этого раздела, продемонстрируем, как можно   использовать </p>
     <p>MySQL в качестве простого калькулятора, введя, к примеру, такой   запрос:</p>
     <blockquote>
       <pre>  mysql&gt; select cos(pi()/10), (2*5)-5;  </pre>
     </blockquote>
	 <a name=#sql>
     <h4 class="style5">Язык SQL</h4>
     <p>Структурированный язык запросов SQL позволяет производить</p>
     <p> различные операции с базами данных: создавать таблицы,</p>
     <p> помещать, обновлять и   удалять из них данные, производить </p>
     <p>запросы из таблиц и т.д. Далее мы   последовательно рассмотрим </p>
     <p>все эти операторы.</p>
     <p><strong><em>Замечание</em></strong></p>
	 <p><em>Не смотря на то, что последний стандарт SQL принят в 1992 </em></p>
	 <p><em>году,   на сегодняшний день нет ни одной базы данных, где бы он</em></p>
	 <p><em> полностью выполнялся.   Более того, в различных базах данных</em></p>
	 <p><em> часть операций осуществляется по-разному.   Мы будем </em></p>
	 <p><em>придерживаться диалекта SQL характерного для СУБД MySQL </em></p>
	 <p><em>поэтому не все   запросы могут выполняться для других баз данных.</em></p>
	 <a name=#put>
</div>

</body>

</html>
